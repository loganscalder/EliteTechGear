% Forecasted Invnetory Needs
% generated by Logan Calder
% `r as.character(format(Sys.Date(), format="%B %d, %Y"))`

```{r, include = F}
# This process of predicting inventory needs cannot be left alone to run 
# independently. A particular threat to safe inventory predictions is the presence 
# of outliers. I've made things so that you can set a certain level of outliers to
# remove, but I know this may remove data that you would want to see.
# The best solution to removing the appropriate outliers may be this:
# If for a particular product, you think there is a week that should not be used
# to forecast inventory, then you should delete that product from the downloaded csv
# file for that week. In this way, you can delete low sales that came because of mistakes
# in inventory or spikes in sales that came from an atypical promotion. 
# 
# The default now is to have the extreme outliers removed by the program. 
# This can be changed to remove fewer, more, or no outlieres.
```

```{r global_options, include = F}
knitr::opts_chunk$set(echo=FALSE, warning = FALSE)
```

```{r}
# Testing
  source("getUrls function.R")
  source("slashToDash.R")
  weeks = "allInDirectory"
```

```{r}
### three lines commented for testing, maybe permanently
# checkInventory = function(weeks = "allInDirectory",  
#                           over.underEstimation = 0
#                           ){
  source("checkInventory internal functions.R")
  library(plyr, quiet = T)
    # find order files and Source the data 
  availableFiles = list.files(pattern = "^skuOrders")
  if(weeks == "allInDirectory"){
      # files of weekly SKU orders should start with "skuOrders"
    skuOrderFiles = availableFiles 
    weeks = substr(skuOrderFiles, start = 10, stop = 19)
  } else{
    skuOrderFiles = paste0("skuOrders", weeks, ".csv")
  }
  
    #Read in
  skuOrders = mapply(FUN = readWithDate, 
                     file = skuOrderFiles,
                     week = weeks,
                     # MoreArgs = list(characterAsStings = F),  
                     # I thought I would need the above to allow a clean rbind. 
                     # I thought rbind on different sets of factors would mess things up
                     # I was wrong... when do restrictions on factors come into play?
                     SIMPLIFY = F,
                     USE.NAMES = F
  )
    #Bind weekly orders
  skuOrders = do.call(what = rbind, skuOrders)
  skuOrders = mutate(skuOrders, 
                     Units.Ordered = 
                       as.numeric(
                         gsub(pattern = "([$%,])", rep = "", x = Units.Ordered)))
  #Take care of duplicates given by Amazon...
  skuOrders = ddply(skuOrders,
                    .fun = summarise, 
                    .var = .(SKU, weekOf),
                    Units.Ordered = sum(Units.Ordered))
 
  message(paste0("I will be using a total of ", 
                 length(skuOrderFiles), 
                 " order files",
                 "\n\nThat's a total of ",
                 length(skuOrderFiles) * 7,
                 " days \n",
                 "\nfiles \n", 
                 paste(skuOrderFiles, collapse = "\n"), 
                 "\nwill be used to predict future orders.",
                 "\nRevise your function inputs or file names if this doesn't look correct"))
  
    # find inventory, check
  inventoryFile = list.files(pattern = "^InventoryInStockReport") # the default name given by amazon
  if(length(inventoryFile) == 1){
  message(paste0("\nCheck: \nfile \n ",
                 inventoryFile,
                 "\nwill be used as a measure of current inventory"))
  currentInventory = subset(read.csv(inventoryFile), select = c("SKU", "Current.Inventory"))
  currentInventory$Current.Inventory = 
    as.numeric(
      gsub(pattern = "([$%,])", rep = "", x = currentInventory$Current.Inventory)
    )
  # sometimes we have two of the same SKU down in inventory...
    # let's add them together?
  currentInventory = 
    ddply(currentInventory, 
          .var = "SKU",
          .fun = summarise,
          Current.Inventory = sum(Current.Inventory)) 
  } else if(length(inventoryFile) ==0){
  stop(paste0("\nIt looks like you don't have inventory data in the working directory.\n",
              "The working directory is ", 
              getwd(),
              "\nPlease download current inventory from 'https://sellercentral.amazon.com/hz/sellingcoach/inventory'
              and save the file as something that starts with 'InventoryInStockReport'.")
  )
  }else 
    stop(paste0("\n  It looks like you have more than one file of inventory data in the working directory. \n",
                "I'm only a machine and can't decide which to choose.\n",
                "I see \n ", paste(inventoryFile, collapse = ", "),
                "\nWill you remove the extra files and try rerunning the function again?"))
```

## Here are the outliers

Here is information on the outliers that the computer chose to take out. 
The column titled, "outlier" gives the number of Units.Ordered for the week 
of the outlier.

```{r boxplot, include = F}
   # find outliers
 
  b = boxplot(Units.Ordered ~ SKU, skuOrders, range = 10, xaxt = 'n')
```
```{r outliers}
  outies = 
    data.frame(outlier = b$out,  
               SKU = b$names[b$group], 
               lowerWhisker = b$stats[1, b$group],
               uppperWhisker = b$stats[5, b$group],
               sampleSize = b$n[b$group]
    )
  # outies
  outiesAndDates = merge(outies, skuOrders, 
                         by.x = c("outlier", "SKU"), 
                         by.y = c("Units.Ordered", "SKU"),
                         all.x = T,
                         suffixes = c("", ""))
  names(outiesAndDates) = c("outlier", "SKU", "lowerWhisker", "upperWhisker",
                            "sampleSize", "weekOfOutlier")
  outiesAndDates
  rm(outies)

    # remove outliers
  skuOrders = #skuOrders 
    merge(skuOrders, outiesAndDates[c("outlier", "SKU", "weekOfOutlier")],
          by.x = c("weekOf", "SKU"),
          by.y = c("weekOfOutlier", "SKU"), 
          all.x = T,
          suffixes = c("", "")
          )
  skuOrders = mutate(skuOrders, outlier = !is.na(outlier))
  
  trimmedOrders = skuOrders[!skuOrders$outlier,]

  # Make predictions: max(lm(data), max(data))
  library(nlme)
  X = lmList(Units.Ordered ~ weekOf | SKU, skuOrders[!skuOrders$outlier,])
```


```{r, include = F}
#The linear model for all products looks like:
X
```


```{r, include = F}
attributes(X[[1]])
# The attributes with in each model:
#interested in measuring confidence of the model
(X[[1]]$residuals)
```


```{r, include = F}
#And attributes of the summary: 
attributes(summary(X[[1]]))
summary(X[[1]])$residuals
```

```{r}
# These last three outputs make me think that we can judge our confidence in the inventory predictions by three criteria:
# * Does the model follow expectations? (positive growth?)
# * Does the model fit? (R^2 for now... err on the side of "no" allowing for much subjectivity)
# * Is the model built on a good-sized sample? (six data points?)
# 
# The inventory for a product of any model that can't answer "yes" to any of the above three will be reviewed by the proper person.
# 
# Let's make a data frame that shows the lm slope, model sample size, rsquared, current inventory, lm forecasted 90 day needs, 90 day needs from recent max, 90 day needs from recent avg, 
```

```{r include = F}
# First get SKU's, sample size, slope, and R^2 from the model
models = lapply(X, `[[`, 12)
sampleSize = lapply(models, nrow)
  sampleSize = as.data.frame(do.call(rbind, sampleSize))
  names(sampleSize) = "sampleSize"

slopes = lapply(X, `[[`, c(1,2))
  slopes = as.data.frame(do.call(rbind, slopes))  # worry about rounding later
  names(slopes) = "slope" 

summaries = lapply(X, summary)
rSquared = lapply(summaries, `[`, 8)
  rSquared = as.data.frame(do.call(rbind, rSquared))

modelConfidence = 
  cbind(rSquared, slopes, sampleSize)
modelConfidence = data.frame(SKU = rownames(modelConfidence), modelConfidence, row.names = NULL)

wonderTable = merge(modelConfidence, currentInventory, 
                    by = "SKU",
                    all = T, 
                    suff = c("",""))
head(wonderTable)
```
```{r}
# Now add the expected needs
  # from linear model, add the predictions, but make negatives zero
  inventoryDate = 
    as.Date(
      substr(inventoryFile, start = 30, sto = 40),
      format = "%d-%m-%Y")
  datesOfNext13Weeks = 
    inventoryDate + seq(fro = 0, to = 84, by = 7)
  
  weeklyForecast= 
    predict(X, 
            data.frame(weekOf = datesOfNext13Weeks), 
            asList = T)
  lm90DayNeeds = lapply(weeklyForecast,addPositive)
  lm90DayNeeds = data.frame(lm90DayNeeds = do.call(rbind, lm90DayNeeds))
  
  # 90 day needs est from recent max
  maximums = 
    ddply(trimmedOrders,
          .var = "SKU",
          .fun = summarise,
          max = max(Units.Ordered))
  fromMax90DayNeeds = data.frame(fromMax90DayNeeds = maximums[[2]]*13,
                                 row.names = maximums$SKU)
  # 90 day needs est from 13 week avg
  means = 
    ddply(trimmedOrders,
          .var = "SKU",
          .fun = summarise,
          means = mean(Units.Ordered)) 
  fromMean90DayNeeds = 
    data.frame(fromMean90DayNeeds = means[[2]]*13,
               row.names = means$SKU)
  # Merge things
  forecasts = cbind(fromMax90DayNeeds, fromMean90DayNeeds, lm90DayNeeds)
  forecasts = data.frame(SKU = rownames(forecasts), forecasts, row.names = NULL)
#head(forecasts)
```

```{r}
asunderTable = merge(wonderTable, forecasts, by = "SKU",
                     all = T,
                     suff = c("", ""))
```

# Forecasted Inventory Needs

Below you'll find all the products (and only those products) that have been 
marked as potentially understocked. 

Products were considered potentially understocked if current inventory levels
were either below the amount of inventory needed for 13 weeks as predicted by 
the linear model or below the amount needed if the maximum number of sales in recent 
weeks were to continue for the next 13 weeks. 

Those potentially understocked are then split into two groups based on the 
confidence we have in the inventory forecast for the SKU. 

### Some data definions
First, I thought I should include a few definitions of the data that isn't perfectly 
self explanatory

* fromMax90DayNeeds - The level of inventory needed for 13 weeks (90 days)
if the maximum level of weekly Units.Ordered from the given weeks were to continue
* fromMean90DayNeeds - The level of inventory needed for 13 weeks if the average 
level of weekly Units.Ordered from the given weeks were to continue.
* lm90DayNeeds - Level of inventory needed for 13 weeks if the trend predicted by the 
linear model were to continue
* Current.Inventory - Inventory level reported by Amazon. Taken directly from 
downloaded inventory report. This is only as current as the last downloaded data.


## High Model Confidence, low inventory

```{r High_Confidence_Low_Inventory}


confidentTable = subset(asunderTable, 
                        subset = 
                          ( #r.squared > confidence &  ## r.squared wont matter
                             slope > 0 &
                             sampleSize > 5))
highConfLowInv = 
  subset(confidentTable,
         subset = 
           Current.Inventory < fromMax90DayNeeds |
           Current.Inventory < lm90DayNeeds,
         select = 
           c("SKU", "Current.Inventory", 
             "fromMax90DayNeeds", "lm90DayNeeds"))
```

```{r update_theme}
require(ggplot2,quietly = T)
theme_update(
  axis.text.x = element_text(angle = -85))
```


```{r print_highConf_lowInv, include = T, results = "asis", fig.width = 10}
require(xtable, quiet = T)


print(xtable(highConfLowInv), type = "html", include.rownames = FALSE)
relevantSkus = highConfLowInv$SKU

ggplot(subset(trimmedOrders, SKU %in% relevantSkus),
       aes(x = weekOf, y = Units.Ordered)) + 
  geom_point() + 
  stat_smooth(method = "lm", fullrange = T) + 
  facet_wrap( ~ SKU) + 
  scale_x_date(breaks = "1 week") + # as.Date(weeks, format = "%m-%d-%Y") maybe works 
  ggtitle("Order History for SKU's (with low inventory according to a sufficient model)")


# xyplot(x = Units.Ordered ~ weekOf | SKU, 
#        data = trimmedOrders, type = c("p", "r"),
#        subset = SKU %in% relevantSkus
#        )
```


## Low Model Confidence, Unknown Inventory Status

```{r not_confident_inventory}
confidentSkus = confidentTable$SKU
notConfidentTable = subset(asunderTable,
                           subset = !(SKU %in% confidentSkus),
                           select = c("SKU", "slope", "sampleSize",
                                      "Current.Inventory", 
                                      "fromMax90DayNeeds",
                                      "fromMean90DayNeeds",
                                      "lm90DayNeeds"))
```

This section describes products that are potentially understocked and either have
little data and/or a negative trend. (My thought is that hopefully negative trends
are unexpected and shouldn't be trusted.... :) )

```{r, fig.width = 15, fig.height= 8, include = T}
notConfLowInv =
  subset(notConfidentTable,
         subset =
           Current.Inventory <= fromMax90DayNeeds |
           Current.Inventory <= lm90DayNeeds)
notConfLowInvSkus = notConfLowInv$SKU
notConfLowInvOrders = subset(trimmedOrders,
                             SKU %in% notConfLowInvSkus)
notConfLowInv = 
  arrange(notConfLowInv, 
          desc(slope)
          )
notConfLowInvOrders$SKU <- 
  factor(notConfLowInvOrders$SKU, 
         levels = notConfLowInv$SKU)

ggplot(notConfLowInvOrders,
       aes(x = weekOf, y = Units.Ordered)) + 
  geom_point() + 
  stat_smooth(method = "lm", fullrange = TRUE) + 
  facet_wrap( ~ SKU, ncol = 6, scales = "free_y") + 
  scale_x_date(breaks = "1 week") + 
  coord_cartesian(ylim = c(-15, max(notConfLowInvOrders$Units.Ordered) + 20)) + 
  ggtitle("Order history for SKU's (with Low Inventory according to a questionable model)")
``` {r , results = "asis", include = T}
print(xtable(notConfLowInv), type = "html", include.rownames = FALSE)

```
